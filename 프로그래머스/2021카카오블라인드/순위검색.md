출처 : https://programmers.co.kr/learn/courses/30/lessons/72412

중복 for문으로 문제 풀기를 시도 했지만 정답은 맞았지만 효율성에서 다 틀렸다.
이 문제는 조합 사용하여 모든 경우의 수를 다 찾고, 이분탐색으로 점수를 찾는다.

```java
import java.util.*

public class algorithm {
  static Map<String, List<Integer>> map = new HashMap<>();
	static String[] temp;
  
  public static void main(String[] args) {
    temp = new String[4];
		
		for (int i = 0; i < info.length; i++) {
			dfs(0, info[i].split(" "));
		}
		
		for (String key : map.keySet()) {
			Collections.sort(map.get(key));
		}
			
		int[] answer = new int[query.length];
		for (int i = 0; i < query.length; i++) {
			String temp = query[i].replaceAll(" and ", "");
			answer[i] = counting(temp.split(" ")[0], Integer.parseInt(temp.split(" ")[1]));
		}
  }
  
  public static void dfs(int level, String[] info) {
		if (level == 4) {
			String str = "";
			for (String s : temp) {
				str += s;
			}
			if (map.containsKey(str)) {
				map.get(str).add(Integer.parseInt(info[4]));
			} else {
				List<Integer> list = new ArrayList<>();
				list.add(Integer.parseInt(info[4]));
				map.put(str, list);
			}
		} else {
			temp[level] = info[level];
			dfs(level+1, info);
			temp[level] = "-";
			dfs(level+1, info);
		}
	}
  
  public static int counting(String str, int n) {
		if (map.containsKey(str)) {
			int left = 0;
			int right = map.get(str).size() - 1;
			
			while (left <= right) {
				int mid = (left+right)/2;
				if (map.get(str).get(mid) < n) {
					left = mid + 1;
				} else {
					right = mid - 1;
				}
			}
			return map.get(str).size() - left;
		}
		
		return 0;
	}
}
```
